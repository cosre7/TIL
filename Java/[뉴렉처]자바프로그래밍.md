# 목차
- [목차](#목차)
- [자바프로그래밍](#%EC%9E%90%EB%B0%94-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
    - [프로그래밍과 프로그래밍 언어](#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4) 
- [윈도우즈에 OpenJDK8 설치하기](#%EC%9C%88%EB%8F%84%EC%9A%B0%EC%A6%88%EC%97%90-openjdk8-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0)   
    - [컴파일러 다운로드](#%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C)   
--
- [자바 언어의 특징](#%EC%9E%90%EB%B0%94-%EC%96%B8%EC%96%B4%EC%9D%98-%ED%8A%B9%EC%A7%95)
    - [Green Project(Stealth Project)](#green-projectstealth-project)    
    - [C/C++ 언어가 가지는 문제점들](#cc-%EC%96%B8%EC%96%B4%EA%B0%80-%EA%B0%80%EC%A7%80%EB%8A%94-%EB%AC%B8%EC%A0%9C%EC%A0%90%EB%93%A4)
    - [자바 언어의 특징(C++과 비교했을 때)](#%EC%9E%90%EB%B0%94-%EC%96%B8%EC%96%B4%EC%9D%98-%ED%8A%B9%EC%A7%95c%EA%B3%BC-%EB%B9%84%EA%B5%90%ED%96%88%EC%9D%84-%EB%95%8C)
- [자바 플랫폼의 특징](#%EC%9E%90%EB%B0%94-%ED%94%8C%EB%9E%AB%ED%8F%BC%EC%9D%98-%ED%8A%B9%EC%A7%95)
    - [새로운 WORA API의 탄생 - platform independent](#%EC%83%88%EB%A1%9C%EC%9A%B4-wora-api%EC%9D%98-%ED%83%84%EC%83%9D---platform-independent) 
- [자바 번역기의 특징](#%EC%9E%90%EB%B0%94-%EB%B2%88%EC%97%AD%EA%B8%B0%EC%9D%98-%ED%8A%B9%EC%A7%95)
    - [WORA를 지원하기 위한 자바 프로그래밍 방법](#wora%EB%A5%BC-%EC%A7%80%EC%9B%90%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%EC%9E%90%EB%B0%94-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B0%A9%EB%B2%95)
- [값의 종류와 표현방법](#%EA%B0%92%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%ED%91%9C%ED%98%84%EB%B0%A9%EB%B2%95)
    - [자바에서의 값의 종류와 표현방법](#%EC%9E%90%EB%B0%94%EC%97%90%EC%84%9C%EC%9D%98-%EA%B0%92%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%ED%91%9C%ED%98%84%EB%B0%A9%EB%B2%95)
- [값의 진법 변환](#%EA%B0%92%EC%9D%98-%EC%A7%84%EB%B2%95-%EB%B3%80%ED%99%98) 
    - [2진수와 10진수](#2%EC%A7%84%EC%88%98%EC%99%80-10%EC%A7%84%EC%88%98) 
    - [비트 형식](#비트-형식)
- [값의 형식명칭과 변환](#값의-형식명칭과-변환)
    - [값의 종류와 형식명칭](#값의-종류와-형식명칭)
# 자바 프로그래밍
### 프로그래밍과 프로그래밍 언어
- 모든 버전의 공통분모인 자바 프로그래밍   
![image](https://user-images.githubusercontent.com/76677629/127772045-bee556a7-d9fd-47b0-ade6-6f3942d2f4a8.png)
    - 자바 언어와 자바 프로그래밍은 다르다.
    - 자바 언어 : 자바 6, 7, 8, 9... 버전별로 나타나고 있는 언어적인 스펙에 대해 다루는 것
    - 자바 프로그래밍 
        - 버전과 달리 알아야 할 기본기
        - 자바를 사용해서 절차를 만드는 방법을 배우는 것
        - 자바를 이용해서 컴퓨터 프로그램을 만드는 방법
        
- 동일한 프로그램이지만 방법을 달리 만들 수 있다.   
![image](https://user-images.githubusercontent.com/76677629/127772090-1c80c70d-fe26-4de1-bd2d-22bf80f37656.png)
    - 자바 프로그래밍이란 것은 절차를 구현해내는 능력을 갖는 것.
    - 프로그램이 동작하는 것은 똑같지만 그것을 구조적으로 만드느냐 객체지향적으로 만드느냐라는 방법을 달리해서 만들 수 있다. 

# 윈도우즈에 OpenJDK8 설치하기
### 컴파일러 다운로드
- 두 가지 버전의 컴파일러
![image](https://user-images.githubusercontent.com/76677629/127772219-4c0714f3-b892-464f-a7e6-a74b92829d55.png)
    - JDK는 jcp.org에서 여러 기업들이 모여서 함께 개발한다.
    - 오라클 : 유료화
    - OpenJDK : 무료 JDK   
- Open JDK 8.0 받기
    - https://github.com/ojdkbuild/ojdkbuild  
    - 압축버전 방식(zip) 추천
- cmd(명령창)
    - C:~> : C 드라이버를 가리키는 상태
    - D 드라이버로 바꾸고 싶을 때
        - d: 라고 작성한다. 
    - cd : change directory -> 경로가 바뀐다.
        - ex) cd tools -> d:\tools>
    - dir : 디렉토리 안에 있는 목록 보기
    - cd.. : 한 칸 위 디렉토리로 이동하기
- javac(컴파일러) 실행   
    - 방법1. javac가 있는 디렉토리로 이동하기   
        - javac~ 명령어 사용하기  
        - javac가 있는 디렉토리에서만 사용 가능하다.
    - 방법2. path(환경변수) 지정해주기
        - 어떠한 디렉토리에서도 사용 가능하다.
- path(환경변수) 설정하기   
    1. 파일탐색기 > 내PC 오른쪽 클릭 > 속성 > 고급시스템 설정 > 환경 변수
        - ~에 대한 사용자 변수 : 현재 로그인 된 사용자만 사용할 수 있는 설정이 된다.
        - 시스템 변수 : 시스템을 사용하는 모든 사용자를 대상으로 설정한다.
    2. 시스템 변수 > Path > 새로만들기 > javac가 있는 디렉토리 주소
        - ~bin 디렉토리
    3. cmd 재실행
    
# 자바 언어의 특징
### Green Project(Stealth Project)
- 가전제품에 프로그램을 심을 생각으로 자바를 만들었다.
- C++로 진행을 하다가 문제점을 느껴 자바를 만들게 되었다.

### C/C++ 언어가 가지는 문제점들
- 객체 생성과 제거
    - 객체 생성과 제거가 쌍으로 이루어지지 못하는 현상이 발생한다.
    - 제거가 안되는 객체가 메모리상에 존재하게 되고 메모리누수가 발생한다.   
    -> delete 키워드 제거   
        - java 실행 환경에서 자동적으로 수행하도록.
        - 개발자는 객체 생성만.
- 참조변수와 포인터 변수   
    -> 객체의 포인터 제거
- 이차 이상의 포인터 문제   
    -> 모든 포인터 제거
- 데이터 구조를 정의하는 두 가지 방법   
    - struct, class      
    -> struct 키워드 제거
- 함수지향? 객체지향?   
    - 함수는 무조건 캡슐화되어서 사용되게끔 메소드로만   
    -> 함수는 메소드로만 사용하도록 제약     
- 컬렉션의 부재   
    -> 언어에 컬렉션을 포함
- 글로벌한 문자 데이터처리의 복잡성   
    -> 다양한 인코딩 문자열 기능 개선
- 기타 등등   
    -> 제거
### 자바 언어의 특징(C++과 비교했을 때)
- 간결성
- 언어에 컬렉션 포함
- 완전한 객체지향 언어

# 자바 플랫폼의 특징
### 새로운 WORA API의 탄생 - platform independent   
![image](https://user-images.githubusercontent.com/76677629/127865688-e94ad105-e56a-40fd-aa14-1c25860a9f2b.png)
- 자바는 기본적으로 WORA를 구현하기 위해 만들어졌다.
- WORA : Write Once Run Anywhere (한 번 작성해서 모든 곳에서 실행할 수 있다)
- 운영체제가 다를 때 API가 서로 상이하게 작동할 수 있다.
- API가 모양은 다르지만 기능은 동일할 수 있다.   
![image](https://user-images.githubusercontent.com/76677629/127866091-50d3f4f8-badb-4723-98ef-f53512eb2bf0.png)
- 자바는 운영체제를 가지고 있는 환경에서 실행되는 프로그램이 API가 달라서 각각 운영체제용으로 만들어지는 것을 피할 수 있도록 단일한 API를 제공해준다.
- 운영체제에 자바 플랫폼만 설치하면 단일한 자바 API를 사용할 수 있다.
- 자바 프로그램은 자바 API만을 이용해서 프로그램을 만들게 된다.
- 자바 플랫폼을 반드시 먼저 설치해야한다는 단점이 있다.
- 각 운영체제만이 가지고 있는 기능에 대해서는 자바 플랫폼이 단일화시킬 수 없다.
    - 특정 운영체제가 가지고 있는 API를 자바 플랫폼에서 가지고있지 않을 수도 있다.   

# 자바 번역기의 특징
### WORA를 지원하기 위한 자바 프로그래밍 방법
- API를 자바 API로 단일화시켜도 생길 수 있는 문제
    - CPU가 한 종류가 있는 것이 아니라 여러 종류가 있으면 기계어로 바꼈을 때 실행에 문제가 생긴다.
        - ex) intel CPU에서 번역이 되면 intel CPU에서만 실행이 된다. 
- 번역 단계
    1. 형태소분석
    2. 구문분석
    3. 의미분석
    4. 중간코드
    5. 최적화
    6. 물리코드
    - 1단계 ~ 4단계 : 컴파일러 사용 -> 개발자가 사용
    - 4단계 ~ 6단계 : 인터프리터 사용 -> 사용자가 사용
    - 자바코드 -> 바이트코드(의사코드, 중간코드, 가상CPU코드) -> 어셈블코드 -> 기계(이진)코드
![image](https://user-images.githubusercontent.com/76677629/127867659-d6c8b7d6-ec5b-4785-8a54-4fa4f5476a59.png)

# 값의 종류와 표현방법
### 자바에서의 값의 종류와 표현방법
- 진리값이 정수값의 0과 1로 표현되는 언어도 있고 따로 진리값으로 표현되는 언어도 있다.
- 자바는 진리값을 따로 가지고 있는 언어이다.
- 정수값
    - 진법은 따로 표기를 해주어야 한다.
        - 0x : 16진수
        - 0 : 8진수
        - 0b : 2진수
    - 수학에서는 무한대의 값을 표현할 수 있지만 자바에서는 한계가 있다. (물리적인 장치이기 때문)
        - 정수값은 최대 32비트(4바이트)로 표현한다. 
        - 26L : 8바이트 -> 사용할 수 있는 정수값의 크기가 커진다.    
- 실수값
    - 123.4f : float, 4바이트
    - 123.4d : double, 8바이트 = 123.4 (d 생략가능)
    - 1.234e2 : 지수표현법 (소수점이 이동한 수를 e 뒤에 써준다.)
    - 1.234e2f, 1.234e2d 형식의 표현도 가능하다.
- 문자값
    - A -> 기호로 인식된다. => 'A' 라고 써준다.
    - 'A' == '\u0065'
- 진리값
    - true
    - false

# 값의 진법 변환
### 2진수와 10진수
- 2진수 -> 10진수
    - 00010110 : 2 + 4 + 16 = 22
    - 00000111 : 1 + 2 + 4 = 7
- 10진수 -> 2진수
    - 6 = 2 + 4 => 00000110
    - 11 = 1 + 2 + 8 => 00001011

### 비트 형식
- 비트 4개를 묶어서 읽으면 16진수가 된다.
    - 00000110 => 0000 0110 => 0 6 => 0x06 
    - 00001011 => 0000 1011 => 0 11 => 0 B => 0x0B = 0x0b
- 비트 3개를 묶어서 읽으면 8진수가 된다.
    - 00000110 => 00 000 110 => 0 0 6 

# 값의 형식명칭과 변환
### 값의 종류와 형식명칭
- 정수형식과 변환
    - 26(4바이트) = 0x1A(4바이트)
    - 형식 : 종류 + 값의 크기
        - 1바이트 : byte 정수         26
        - 2바이트 : short 정수        26
        - 4바이트 : int 정수          26
        - 8바이트 : long 정수         26L
    - long x = 30; -> 수학에서는 무한대로 표현이 가능하지만 컴퓨터는 물리적인 장치이기 때문에 long 과 같이 크기를 한정한다.
        - 30은 int 형, x는 long 형이기 때문에 원래는 에러가 나야하지만 묵시적으로 에러가 나지 않는다.
    - byte x = 30; 
        - 1바이트 크기의 x 안에 30(기본 int 형)은 들어갈 수 있을 수도 있고 없을 수도 있다.(손실이 일어날 수 있다.) -> 컴파일과정에서 에러를 발생시킨다. (형식에 맞지 않다)
            - byte x = (byte)30; 으로 명시적으로 변환해주어야 한다. 
- 실수형식
    - 26.5 = 2.65e1
    - 4바이트 : float x = 3.5; -> 3.5가 기본 double형이기 때문에 에러가 난다.
        - float x = (float)3.5; 라고 해주면 에러가 나지 않는다.   
    - 8바이트 : double x = 3.5f; -> 묵시적으로 형태가 바뀌기 때문에 에러가 나지 않는다.     
- 문자형식
    - 2바이트 : char
- 부울형식
    - 1비트 : boolean -> 1 or 0   
![image](https://user-images.githubusercontent.com/76677629/128186509-75db123a-f388-4d0f-82c7-f17f08b5f5fa.png)










































